исходный код:  http://www.mhprofessional.com/product.php?isbn=0071808558 или http://www.williamspublishing.com/Books/978-5-8459-1918-2.html / Герберт Шилдт. Java 8. Полное руководство, 9-е издание
psvm / sout /
char c = '65'; 		// ошибка компиляции(сразу подчеркивает)
char b = '\141';	// a	\  (косая черта) для ввода значений в восьмеричной форме
char b = '\u0061';	// a	\u  в шестнадцатеричной форме
char c = '9';  		// 9
char c = 65;   		// A
char c = 'A';  		// A
int x = 08; (и 09)	// ошибка компиляции (восьмеричная система исчисления)
int x = 010; 		// вывод: 8 (010(восьмеричная) == 8(десятиричная))
 
* ПРИВЕДЕНИЕ ТИПОВ - явное преобразование типов.
* АВТОМАТИЧЕСКОЕ ПРОДВИЖЕНИЕ ТИПОВ В ВЫРАЖЕНИЯХ - byte, short, char автоматически продвигается к типу int(чтобы не выйти за пределы диапазона допустимых значений), (выражения выполняется с помощью целочисленных, а не байтовых значений), (byte = byte + byte - работать не будет)
* ПРАВИЛА ПРОДВИЖЕНИЯ ТИПОВ - сначала все значения типа byte, short, char продвигаются к типу int. Затем тип всего выражения продвигается к типу long, если один из его операндов относится к типу long.
  Если же один из операндов относится к типу float, то тип всего выражения продвигается к типу float. А если любой из операндов относится к типу double, то и результат вычисления всего выражения относятся к типу double.

int two[][] = new int[4][5]; / 4-строка / 5-столбец

ПОБИТОВЫЕ (ПОРАЗРЯДНЫЕ) ОПЕРАТОРЫ: (можно выполнять над целочисленными типами данных: long, int, short, char, byte)
	~		Поразрядная унарная операция НЕ
	&		Поразрядная логическая операция И
	|		Поразрядная логическая операция ИЛИ
	^		Поразрядная логическая операция исключающее ИЛИ
	>>		Сдвиг вправо
	>>>		Сдвиг вправо с заполнением нулями
	<<		Сдвиг влево											// a << 1 (сдвиг на 1 позицыю, умножит на 2 (если не вылезет за пределы типа данных))
	&=		Поразрядная логическая операция И с присваиванием
	|=		Поразрядная логическая операция ИЛИ с присваиванием
	^=		Поразрядная логическая операция исключающее ИЛИ с присваиванием
	>>=		Сдвиг вправо с присваиванием
	>>>=	Сдвиг вправо с заполнением нулями и присваиванием
	<<=		Сдвиг влево с присваиванием

ЛОГИЧЕСКИЕ ОПЕРАЦИИ: (применяются только с boolean)
	&	Логическая операция И								false & false = FALSE 		true & false = FALSE 	false & true = FALSE  	true & true = TRUE
	|	Логическая операция ИЛИ								false | false = FALSE 		true | false = TRUE 	false | true = TRUE  	true | true = TRUE
	^	Логическая операция исключающее ИЛИ					false ^ false = FALSE 		true ^ false = TRUE  	false ^ true = TRUE  	true ^ true = FALSE
	!	Логическая унарная операция НЕ						false ! false = TRUE  		true ! false = FALSE  	false ! true = TRUE  	true ! true = FALSE
	||	Укороченная (условная) логическая операция ИЛИ		когда значение A == true, второе, ПРАВОЕ значение вычислять не нужно - всеравно будет true
	&&	Укороченная (условная) логическая операция И		когда значение A == false, второе, ПРАВОЕ значение вычислять не нужно - всеравно будет false
	&=	Логическая операция И с присваиванием
	|=	Логическая операция ИЛИ с присваиванием
	^=	Логическая операция исключающее ИЛИ с присваиванием
	==	Равенство
	!=	Неравенство
	?:	Тернарная условная операция							k = x < 0 ? -x : x; 	если x < 0 == true, в переменную k запишется -x, ...

ПРИОРИТЕТ ОПЕРАЦЫЙ:
	x++   x--
	++x	  --x  ~  !  +(унарная)  -(унарная)  приведение типов
	*  /  %
	+  - 
	>>  >>>  <<
	>  >=  <  <=  instanceof
	==  !=
	&
	^
	|
	&&
	||
	?:
	->
	=
QQQ-------------------------------------------------------------------------------  if else if, while, for each(итерация в многомерных массивах)  -------------------------------------------------------------------------------

	if(x == 1)				Как только одно из условий оказывается true - выполняется оператор, а остальная часть конструкции if-else-if пропускается
		//...
	else if(x == 2)
		//...
	else if(x == 3)
		//...
	else					Если ни одно из условий не равно true - выполняется заключительный оператор 
		//...
-----
	while(++i < --j);		ТЕЛО цикла while(или любого другого цикла) МОЖЕТ БЫТЬ ПУСТЫМ. / если i = 0; j = 100 получим i = 50; j = 50 (вычисляется среднее значение)
-----
	int nums[][] = {{1, 2, 3}, {4, 5}};			// массив 3x2
	for(int x[] : nums) {
		for(int y : x) {
			System.out.println(y);
		}
	}
QQQ-------------------------------------------------------------------------------  break-goto, continue, continue-goto  -------------------------------------------------------------------------------

	first: {										// метка для break-goto
		second: {
			third: {
				System.out.println("3");
				if(true) break second;				// выполнение будет продолжено с КОНЦА помеченного блока
			}
			System.out.println("2");				// не выведет
		}
		System.out.println("1");					// здесь будет продолжено
	}
ВЫВОД: 3 1
-----
continue: В циклах while и do?while оператор continue вызывает передачу управления непосредственно условному выражению, управляющему циклом. 
В цикле for управление передается вначале ИТЕРАЦИОННОЙ ЧАСТИ цикла for, а затем условному выражению

QQQ-------------------------------------------------------------------------------  finalize() (полное завершение)  -------------------------------------------------------------------------------

Вызывается перед удалением объекта данного класса сборщиком мусора. Не вызывается при выходе объекта из области действия.
Заранее неизвестно, когда будет(и будет ли вообще) выполняться метод finalize(). 
Поэтому в программе должны быть предоставлены другие средства для освобождения используемых объектом системных ресурсов и т.п.
Нормальная работа программы не должна зависеть от метода finalize().

		protected void finalize(){
			//...
		}
QQQ-------------------------------------------------------------------------------  class Stack  -------------------------------------------------------------------------------

Первым пришел - последним обслужен

	class Stack {
		int stck[] = new int[10];
		int tos;

		Stack() {											// инициализировать вершину стека
			tos = -1;
		}

		void push(int item) {								// разместить элемент в стеке
			if (tos == 9)
				System.out.println("Stack is full.");
			else
				stck[++tos] = item;
		}

		int pop() {											// извлечь элемент из стека
			if (tos < 0) {
				System.out.println("Stack underflow.");
				return 0;
			} else
				return stck[tos--];
		}
	}
QQQ-------------------------------------------------------------------------------  static  -------------------------------------------------------------------------------

Переменные экземпляра, объявленные как static, по существу, являются глобальными. 
При объявлении объектов класса этих переменных их копии не создаются. Вместо этого все экземпляры класса совместно используют одну и  ту  же статическую переменную.
На методы, объявленные как static, накладывается следующие ограничения:
	•  Они могут непосредственно вызывать только другие статические методы.
	•  Им непосредственно доступны только статические переменные.
	•  Они никоим образом не могут делать ссылки типа this или super. 
Если для инициализации статических переменных требуется произвести вычисления, то для этой цели достаточно объявить статический блок, который будет выполняться только один раз при первой загрузке класса.

	class One {
		static int a = 3;
		static int b;

		static {
			b = a * 4;
		}

		public static void main(String args[]) {
			System.out.println(b);					// 12
		}
	}

Сначала в переменной а инициализируется значением 3, и переменная b инициализируется значением 0.
Затем выполняется статический блок кода и переменная b устанавливается значением  а*4, т.е. 12

	Имя_класса.метод()/переменная - так можно воспользоватся за пределами класса, в котором определены статические методы и переменные

QQQ-------------------------------------------------------------------------------  Вложенные(static) и внутренние(non-static) классы  -------------------------------------------------------------------------------

Область действия вложенного класса ограничена областью действия внешнего класса.
Вложенный класс имеет доступ к членам (в том числе закрытым) того класса, в который он вложен.
Но внешний класс не имеет доступа к членам вложенного класса.
	* ВЛОЖЕННЫЙ КЛАСС (static) -  должен обращаться к нестатическим членам своего внешнего класса посредством объекта, 
		т.е. вложенный статический класс не может непосредственно ссылаться на нестатические члены своего внешнего класса.
	* ВНУТРЕННИЙ КЛАСС (non-static) - имеет доступ ко всем переменным и методам своего внешнего класса 
и может непосредственно ссылаться на них таким же образом, как это делают остальные нестатические члены внешнего класса.
Экземпляр внутреннего класса может быть создан только в контексте внешнего класса.
	Члены ВНУТРЕННЕГО класса доступны только в области действия внутреннего класса и не могут быть использованы внешним классом.
ВНУТРЕННИЕ классы можно определять в области действия любого блока кода, например в блоке кода относящегося к методу, или даже в теле цикла for.

QQQ-------------------------------------------------------------------------------  Переменная суперкласса ссылаеться на объект подкласса  -------------------------------------------------------------------------------

	class B extends A{}
	a = b;

Доступные члены класса определяются ТИПОМ ССЫЛОЧНОЙ ПЕРЕМЕННОЙ, а не типом объекта, на который она ссьшается. 
Т.е. если ссылочной переменной из суперкласса присваивается ссылка на объект подкласса, то доступ предоставляется только к указанным в ней частям объекта, определяемого в суперклассе.
Именно поэтому у объекта "a" нет доступа к полям класса "b" даже в том случае, когда он ссылается на объект класса "b".
Ведь суперклассу неизвестно, что именно в него добавляет подкласс.

QQQ-------------------------------------------------------------------------------  Динамическая диспетчеризация методов  -------------------------------------------------------------------------------

Динамическая диспетчеризация методов - механизм с помощью которого вызов переопределенного метода разрешается во время выполнения, а не компиляции.
Когда переопределенный метод вызывается по ссылке на суперкласс, нужный вариант этого метода выбирается в зависимости от типа объекта, на который делается ссылка в момент вызова.
Иначе говоря, вариант переопределенного метода выбирается для выполнения в зависимости от типа объекта, на который делается ссылка, а не типа ссылочной переменной.
	A a = new A();
	B b = new B();  	// B extends A
	a = b;
	a.method();			// вызовется метод из класса B

QQQ-------------------------------------------------------------------------------  abstract  -------------------------------------------------------------------------------

	abstract void func();	// тело метода отсутствует. Должно быть реализованно в наследнике/ках

Класс содержащий один или больше абстрактных методов, должен быть также объявлен как абстрактный.
У абстрактного класса не может быть никаких объектов, т.е. экземпляр абстрактного класса не может быть получен с помощью new. 
Нельзя объявлять абстрактные конструкторы или абстрактные статические методы.
Подкласс производный от абстрактного класса, должен реализовать все абстрактные методы из своего суперкласса или же сам быть объявлен абстрактным.

	A a;		// без new (обьект невозможно создать)
	a = b;		// присваиваем ссылку класса B, классу A
	a.func();	// вызываем реализованный в классе B, уже не абстрактный метод. 

QQQ-------------------------------------------------------------------------------  class Object  -------------------------------------------------------------------------------

Оbject - суперклас для всех остальных классов, и ссылочная переменная из класса Object может ссьлаться на объект любого другого класса или массива.
Методы класса Object доступные для любого объекта:

	Object clone()					Создает новый объект, не отличающийся от клонируемого
	boolean equals(Object object)	Определяет, равен ли один объект другому
	void finalize()					Вызывается перед удалением неиспользуемого объекта
	Class<?> get class				Получает класс обьекта во время выполнения
	int hashCode()					Возвращает хеш-код, связанный с вызывающим объектом
	void notify()					Возобновляет исполнение потока, ожидающего вызывающего объекта
	void notifyAll()				Возобновляет исполнение всех потоков, ожидающих вызывающего обьекта
	String toString()				Возвращает символьную строку, описывающую обьект
	void wait()						Ожидает другого потока исполнения

QQQ-------------------------------------------------------------------------------  интерфейсы  -------------------------------------------------------------------------------

Интерфейсы предназначены для поддержки динамического разрешения вызовов методов во время выполнения.
Они изолируют определение метода или набора методов от иерархии наследования. 
А поскольку иерархия интерфейсов не совпадает с иерархией классов, то классы, никак не связанные между собой иерархически, могут реализовать один и тот же интерфейс.
Переменные в объявлениях интерфейсов неявно объявляются как final и static, и должны быть инициализированы.

interface ...		- (без модификатора доступа, по умолчанию), доступен только другим членам того пакета, в котором он объявлен.
public interface...	- может быть использован в любом другом коде, должен быть единственным открытым интерфейсом объявленным в файле

Переменные обьявленные как ссылки на объекты, в которых используется тип интерфейса, а не тип класса, могут ссылаться на любой экземпляр какого угодно класса, 
реализующего объявленный интерфейс, эта переменная не предоставит доступа к каким-нибудь другим членам класса.
Динамический поиск методов во время выполнения == значительние издержки по сравнению с обычным вызовом методов, в прикладном коде, критичном к производительности, интерфейсы следует использовать только тогда, когда это действительно необходимо.
Класс не полностью реализующий интерфейс, должен быть объявлен как abstract.
Расширение интерфейсов - интерфейсы могут наследовать другие интерфейсы.

QQQ-------------------------------------------------------------------------------  Вложенные интерфейсы  -------------------------------------------------------------------------------

Интерфейс может быть бьявлен:
	* членом класса(интерфейс-член)
	* другого интерфейса(вложенный интерфейс). 
Могут быть: public/private/protected. 
За пределами класса или интерфейса, имя интерфейса должно быть уточнено: myClass.myInterface / myInterface1.myInterface2

QQQ-------------------------------------------------------------------------------    -------------------------------------------------------------------------------




255
Методы по умолчанию





































QQQ-------------------------------------------------------------------------------    -------------------------------------------------------------------------------



* когда ребёнка приводим к родителю, поля вызываются родительские, методы ребёнка(если не static)
* переменную из суперкласса можно использовать для ссылки на любой объект, унаследованный от этого класса - но суперклассу будут доступны только его собственные члены.




ПЕРЕГРУЗКА МЕТОДА - у методов одинаковие имена, но разные типы параметров, кол-во параметров, возвращаемый тип - не имеет значения. Если не обнаружено полное соответствие, происходит втоматическое преобразование типов (например: int в double)
РЕКУРСИЯ 		- процесс определения чего-либо относительно самого себя.
FINAL ПОЛЕ 		- должно быть инициализировано во время обьявления, или в конструкторе, принято обозначать прописными буквами.
FINAL МЕТОДЫ 	- преопредилятся в наследниках не могут.
FINAL КЛАСС		- объявление класса завершенным неявно делает завершенными и все его методы.
ПОЗДНЕЕ СВЯЗЫВАНИЕЕ	- вызовы методов динамически во время выполнения.
РАННЕЕ СВЯЗЫВАНИЕЕ 	- final методы не могут быть переопределены, и их вызовы могут быть разрешены во время компиляции.
VARARGS			- (variable-length arguments - аргументы переменной длины) - при перегрузке методов с warargs, если вызвать например: vaTest(); может возникнуть неоднозначность, потому что 
	параметр с warargs может быть пустым, поэтому этот вызов может быть преобразован в вызов метода vaTest(int...) или vaTest(boolean...). (Ещё пример неоднозначности: vaTest(1): static void vaTest(int... v) {} и static void vaTest(int n, int... v) {})
SUPER 			- имет две формы: 1) для вызова конструктора суперкласса(super(x, y)); 2) для обращения к члену суперкласса, скрываемому членом подкласса(super.член_суперкласса_переменная/метод )
PUBLIC CLASS 	- (класс обьявлен как public) доступен из любого другого кода.
CLASS			- (класс обьявлен с уровнем доступа по умолчанию) доступный только для кода из данного пакета.





СКАЧАТЬ: "Лямбда-выражения в Java 8" Ричард Уорбэртон
wix.com - конструктор сайтов, Днепропетровск
IDEA: Ctrl + / --- комментирует всю строку; Ctrl + Shift + / --- комментирует только выделенный участок кода