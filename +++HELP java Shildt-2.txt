исходный код:  http://www.mhprofessional.com/product.php?isbn=0071808558 или http://www.williamspublishing.com/Books/978-5-8459-1918-2.html / Герберт Шилдт. Java 8. Полное руководство, 9-е издание
psvm / sout /
char c = '65'; 		// ошибка компиляции(сразу подчеркивает)
char b = '\141';	// a	\  (косая черта) для ввода значений в восьмеричной форме
char b = '\u0061';	// a	\u  в шестнадцатеричной форме
char c = '9';  		// 9
char c = 65;   		// A
char c = 'A';  		// A
int x = 08; (и 09)	// ошибка компиляции (восьмеричная система исчисления)
int x = 010; 		// вывод: 8 (010(восьмеричная) == 8(десятиричная))

* ПРИВЕДЕНИЕ ТИПОВ - явное преобразование типов.
* АВТОМАТИЧЕСКОЕ ПРОДВИЖЕНИЕ ТИПОВ В ВЫРАЖЕНИЯХ - byte, short, char автоматически продвигается к типу int(чтобы не выйти за пределы диапазона допустимых значений), (выражения выполняется с помощью целочисленных, а не байтовых значений), (byte = byte + byte - работать не будет)
* ПРАВИЛА ПРОДВИЖЕНИЯ ТИПОВ - сначала все значения типа byte, short, char продвигаются к типу int. Затем тип всего выражения продвигается к типу long, если один из его операндов относится к типу long.
  Если же один из операндов относится к типу float, то тип всего выражения продвигается к типу float. А если любой из операндов относится к типу double, то и результат вычисления всего выражения относятся к типу double.

int two[][] = new int[4][5]; / 4-строка / 5-столбец

ПОБИТОВЫЕ (ПОРАЗРЯДНЫЕ) ОПЕРАТОРЫ: (можно выполнять над целочисленными типами данных: long, int, short, char, byte)
	~		Поразрядная унарная операция НЕ
	&		Поразрядная логическая операция И
	|		Поразрядная логическая операция ИЛИ
	^		Поразрядная логическая операция исключающее ИЛИ
	>>		Сдвиг вправо
	>>>		Сдвиг вправо с заполнением нулями
	<<		Сдвиг влево											// a << 1 (сдвиг на 1 позицыю, умножит на 2 (если не вылезет за пределы типа данных))
	&=		Поразрядная логическая операция И с присваиванием
	|=		Поразрядная логическая операция ИЛИ с присваиванием
	^=		Поразрядная логическая операция исключающее ИЛИ с присваиванием
	>>=		Сдвиг вправо с присваиванием
	>>>=	Сдвиг вправо с заполнением нулями и присваиванием
	<<=		Сдвиг влево с присваиванием

ЛОГИЧЕСКИЕ ОПЕРАЦИИ: (применяются только с boolean)
	&	Логическая операция И								false & false = FALSE 		true & false = FALSE 	false & true = FALSE  	true & true = TRUE
	|	Логическая операция ИЛИ								false | false = FALSE 		true | false = TRUE 	false | true = TRUE  	true | true = TRUE
	^	Логическая операция исключающее ИЛИ					false ^ false = FALSE 		true ^ false = TRUE  	false ^ true = TRUE  	true ^ true = FALSE
	!	Логическая унарная операция НЕ						false ! false = TRUE  		true ! false = FALSE  	false ! true = TRUE  	true ! true = FALSE
	||	Укороченная (условная) логическая операция ИЛИ		когда значение A == true, второе, ПРАВОЕ значение вычислять не нужно - всеравно будет true
	&&	Укороченная (условная) логическая операция И		когда значение A == false, второе, ПРАВОЕ значение вычислять не нужно - всеравно будет false
	&=	Логическая операция И с присваиванием
	|=	Логическая операция ИЛИ с присваиванием
	^=	Логическая операция исключающее ИЛИ с присваиванием
	==	Равенство
	!=	Неравенство
	?:	Тернарная условная операция							k = x < 0 ? -x : x; 	если x < 0 == true, в переменную k запишется -x, ...

ПРИОРИТЕТ ОПЕРАЦЫЙ:
	x++   x--
	++x	  --x  ~  !  +(унарная)  -(унарная)  приведение типов
	*  /  %
	+  - 
	>>  >>>  <<
	>  >=  <  <=  instanceof
	==  !=
	&
	^
	|
	&&
	||
	?:
	->
	=
QQQ-------------------------------------------------------------------------------  if else if, while, for each  -------------------------------------------------------------------------------

	if(x == 1)				Как только одно из условий оказывается true - выполняется оператор, а остальная часть конструкции if-else-if пропускается
		//...
	else if(x == 2)
		//...
	else if(x == 3)
		//...
	else					Если ни одно из условий не равно true - выполняется заключительный оператор 
		//...
-----
	while(++i < --j);		ТЕЛО цикла while(или любого другого цикла) МОЖЕТ БЫТЬ ПУСТЫМ. / если i = 0; j = 100 получим i = 50; j = 50 (вычисляется среднее значение)



142



















QQQ-------------------------------------------------------------------------------    -------------------------------------------------------------------------------


















когда ребёнка приводим к родителю, поля вызываются родительские, методы ребёнка(если не static)

СКАЧАТЬ: "Лямбда-выражения в Java 8" Ричард Уорбэртон